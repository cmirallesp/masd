include: Common.2apl;

beliefs:
  stock(Type, Stock):- findall(1, have(_, Type, _), List), length(List, Stock).
  retailPrice(Type, Quality, Price):- type(Type), stock(Type, Stock), c(C), lambda(Lambda),
                                      recommendedPrice(Type, Quality, RPrice),
                                      is(Price, RPrice + int(C*exp(-Lambda*Stock))).
  stockUnderMinimum(ProdType):- type(ProdType), stock(ProdType, Stock),
    minimumStock(Minimum), Stock < Minimum.

  productAvailable(ProductId):- have(ProductId, _, _), onSale(ProductId, _),
                                not(reserved(ProductId, _)).


goals:
  gainMoney.

beliefupdates:
  { not(onSale(Id, _)), have(Id, _, _) } PutOnSale(Id, Price) { onSale(Id, Price) }
  { onSale(Id, Price) } RemoveFromSale(Id) { not onSale(Id, Price) }

pgrules:
  gainMoney <- have(Id, Type, Quality) and not(onSale(Id, _)) |
  {
    B(retailPrice(Type, Quality, Price));
    @env(putOnSale(Id, Quality, Price));
    PutOnSale(Id, Price);
  }

pcrules:
  message(Buyer, request, _, _, wantToBuy(ProductId)) <-
    productAvailable(ProductId) and not(reserved(ProductId, _)) |
  {
    send(Buyer, inform, buyAccepted(ProductId));
    +reserved(ProductId, Buyer);
  }

  message(Buyer, request, _, _, wantToBuy(ProductId)) <- true |
  {
    send(Buyer, refuse, buyRefused(ProductId));
  }

  event(moneyTransfer(Transfer, ProductId), env) <- reserved(ProductId, Buyer) | {
    B(money(MoneyBefore));
    B(is(MoneyAfter, MoneyBefore + Transfer));
    UpdateMoney(MoneyAfter);
    @env(shipProduct(Buyer, ProductId));
    RemoveFromSale(ProductId);
    RemoveItem(ProductId);
  }

